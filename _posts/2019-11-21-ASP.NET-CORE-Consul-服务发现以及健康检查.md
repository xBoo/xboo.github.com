##ASP.NET CORE使用Consul实现服务治理与健康检查

####背景
笔者所在的公司正在进行微服务改造，这其中服务治理组件是必不可少的组件之一，在一番讨论之后，最终决定放弃 Zookeeper 而采用 Consul 作为服务治理框架基础组件。主要原因是 Consul 自带健康检查，通过该功能可以比较方便的监控应用的运行状态，从而更好的运维整个系统。但在实际实施过程中笔者发现，目前网络上所能看到的很多资料，没有比较清晰的解释 Consul 的运行方式，特别是当用户对于 Zookeeper 主动通知的方式比较熟悉之后，对于 Consul 这种每次都通过 HTTP 调用获取服务信息的方式还是存在很多疑惑的，比如：这样的方式在调用链中，不是会导致 HTTP 调用链增加一倍吗？

#### Consul中的一些概念
关于Consul，首先介绍最常见的一副图：
![consul1](/img/consul1.png)
该图表示 Consul 支持的一个重要的功能———多数据中心，这也是很多服务注册发现工具所不具备的，通过上述图中我们可以解读出如下一些信息：
1. Cosnul 分为 Server 和 Client，多数据中心的实现主要依靠两个数据中心的 Server 进行通信，并且每个数据中心有各自的主节点，也就是各自选举。
2. Client 与 Server 之间通过8300端口，TCP协议进行RPC交互。
3. Client 与其他实例之间通过 8301 以 TCP/UDP 协议进行 LAN GOSSIP 交互
> 说明：Client 与其他实例之间的通信，这里其实有一个反熵概念，具体可参考园子里 [波斯码](https://www.cnblogs.com/bossma/tag/Consul/) 所写的文章——[Consul的反熵](https://www.cnblogs.com/bossma/p/11354245.html)，此文章对于反熵概念的解释非常到位，在笔者对于 Consul 的学习阶段，也跟 波斯码 同学私信沟通多轮，他都一一耐心解答，在此一并表示感谢！

反熵的概念总结一句话就是：分而治之，层层汇报。这个特点也同时决定了服务的注册和健康检查方式：通过服务所注册的 Agent 来实现的。如下图所示：
![consul2](/img/consul2.png)

根据上图所示有个重要的概念：
> 1. 如果我们通过 Consul Client 中的 Agent 获取服务时，则只能返回当前这个 Consul Client 中所注册的所有服务
> 2. 而如果我们通过 Consul Server 中的 Catalog 获取服务时，则可以获取到所有注册到 Client 的服务。

事实上即使我们需要获取 Catalog 中的信息时，也无需直接与 Consul Server 交互，而是通过当前服务器 Consul Client 转发请求获取。同时取决于反熵概念，如果我们把每台服务器看作管理的最小单位，那么则需要在每台机器上部署 Consul Client。

如果按照上述信息实施部署，那么我们来看下假如 APP1 调用 APP2 时，具体的调用顺序时怎样的：
![consul3](/img/consul3.png)
如上图所示，这样的部署其实会带来一些问题：
>1. 每台机器上都需要部署 Consul Client
>2. 服务请求链路成倍增加了

问题1 部署成本增加，实际上是一次性工作，况且假如你是容器化部署的话，那这个问题基本可以忽略。
问题2 调用链路增加的确会带来很多问题，主要是在调用 APP2 之前增加了 ① ② 两步，其中步骤 ① 为本机 HTTP 调用，步骤 ② 为 Consul集群内部的 RPC 调用，经过笔者实际测试这个调用耗时在毫秒级，除非对于性能要求很高的情况下，普通的调用链路请求是可以容忍的，而笔者所在公司的方案目前也是基于此方案。如果不能容忍，那只能牺牲部分一致性，在本地进行缓存，并设定合理的同步周期。

>思考一下：笔者认为上述问题是 Consul 反熵机制所带来的缺陷，只有通过主动请求 Consul Server 才能获取所有服务的信息，而又缺少比较好的通知机制，导致应用程序无法缓存服务信息。而相比较于 Zookeeper，由于有了通知机制，使各个应用程序可以缓存服务列表信息，只有当收到通知时，才主动更新服务信息。同时 zookeeper 是长连接，当服务在出现问题时可以更加及时获取到变化，而Consul 必须要依赖健康检查，而健康检查是有周期性的。当然凡事都各有利弊，但我们要知晓个中优缺点，才能更加合理使用。 

相信有了这些概念的理解，我们可以在初次接触 Consul 时减少一些疑惑。那么我们解下来看下，如何在编码中使用 Consul。

#### Consul 在 ASP.NET CORE 中的使用

Consul服务在注册时需要注意几个问题：
1. 那就是必须是在服务完全启动之后再进行注册，否则可能导致服务在启动过程中已经注册到 Consul Server，这时候我们要利用 IApplicationLifetime 应用程序生命周期管理中的 ApplicationStarted 事件。
2. 应用程序向 Consul 注册时，应该在本地记录应用 ID，以此解决每次重启之后，都会向 Consul 注册一个新实例的问题，便于管理。

具体代码如下：

###### 1.服务注册
```csharp
public static IApplicationBuilder RegisterSpider(this IApplicationBuilder app,
    IApplicationLifetime lifetime,
    IConfiguration configuration,
    IConsulClient consulClient,
    ILogger logger)
{
    try
    {
        var urlsConfig = configuration["server.urls"];
        ArgumentCheck.NotNullOrWhiteSpace(urlsConfig, "未找到配置文件中关于 server.urls 相关配置！");

        var urls = urlsConfig.Split(';');
        var port =  urls.First().Substring(httpUrl.LastIndexOf(":") + 1);
        var ip = GetPrimaryIPAddress(logger);
        var registrationId = GetRegistrationId(logger);

        var serviceName = configuration["Apollo:AppId"];
        ArgumentCheck.NotNullOrWhiteSpace(serviceName, "未找到配置文件中 Apollo:AppId 对应的配置项！");

        lifetime.ApplicationStarted.Register(() =>
        {
            var healthCheck = new AgentServiceCheck
            {
                DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),
                Interval = 5,
                HTTP = $"http://{ip}:{port}/health",
                Timeout = TimeSpan.FromSeconds(5),
                TLSSkipVerify = true
            };

            var registration = new AgentServiceRegistration
            {
                Checks = new[] { healthCheck },
                ID = registrationId,
                Name = serviceName.ToLower(),
                Address = ip,
                Port = int.Parse(port),
                Tags = ""
            };

            consulClient.Agent.ServiceRegister(registration).Wait();
            logger.LogInformation($"服务注册成功! 注册地址：{((ConsulClient)consulClient).Config.Address}, 注册信息：{registration.ToJson()}");
        });

        lifetime.ApplicationStopping.Register(() =>
        {
            consulClient.Agent.ServiceDeregister(registrationId).Wait();
        });

        return app;
    }
    catch (Exception ex)
    {
        logger?.LogSpider(LogLevel.Error, "服务发现注册失败！", ex);
        throw ex;
    }
}

private static string GetPrimaryIPAddress(ILogger logger)
{
    string output = GetLocalIPAddress();
    logger?.LogInformation(LogLevel.Information, "获取本地网卡地址结果：{0}", output);

    if (output.Length > 0)
    {
        var ips = output.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
        if (ips.Length == 1) return ips[0];
        else
        {
            var localIPs = ips.Where(w => w.StartsWith("10"));//内网网段
            if (localIPs.Count() > 0) return localIPs.First();
            else return ips[0];
        }
    }
    else
    {
        logger?.LogSpider(LogLevel.Error, "没有获取到有效的IP地址，无法注册服务到服务中心！");
        throw new Exception("获取本机IP地址出错，无法注册服务到注册中心！");
    }
}

public static string GetLocalIPAddress()
{
    if (!string.IsNullOrWhiteSpace(_localIPAddress)) return _localIPAddress;

    string output = "";
    try
    {
        foreach (NetworkInterface item in NetworkInterface.GetAllNetworkInterfaces())
        {
            if (item.OperationalStatus != OperationalStatus.Up) continue;

            var adapterProperties = item.GetIPProperties();
            if (adapterProperties.GatewayAddresses.Count == 0) continue;

            foreach (UnicastIPAddressInformation address in adapterProperties.UnicastAddresses)
            {
                if (address.Address.AddressFamily != AddressFamily.InterNetwork) continue;
                if (IPAddress.IsLoopback(address.Address)) continue;

                output = output += address.Address.ToString() + ",";
            }
        }
    }
    catch (Exception e)
    {
        Console.WriteLine("获取本机IP地址失败！");
        throw e;
    }

    if (output.Length > 0)
        _localIPAddress = output.TrimEnd(',');
    else
        _localIPAddress = "Unknown";

    return _localIPAddress;
}

private static string GetRegistrationId(ILogger logger)
{
    try
    {
        var basePath = Directory.GetCurrentDirectory();
        var folderPath = Path.Combine(basePath, "registrationid");
        if (!Directory.Exists(folderPath))
            Directory.CreateDirectory(folderPath);

        var path = Path.Combine(basePath, "registrationid", ".id");
        if (File.Exists(path))
        {
            var lines = File.ReadAllLines(path, Encoding.UTF8);
            if (lines.Count() > 0 && !string.IsNullOrEmpty(lines[0]))
                return lines[0];
        }

        var id = Guid.NewGuid().ToString();
        File.AppendAllLines(path, new[] { id });
        return id;
    }
    catch (Exception e)
    {
        logger?.LogWarning(e, "获取 Registration Id 错误");
        return Guid.NewGuid().ToString();
    }
}
```
######2.健康检查
```csharp
public static void UseHealth(this IApplicationBuilder app)
{
    app.UseMiddleware<HealthMiddleware>();
}

public class HealthMiddleware
{
    private readonly RequestDelegate _next;
    private readonly string _healthPath = "/health";

    public HealthMiddleware(RequestDelegate next, IConfiguration configuration)
    {
        this._next = next;
        var healthPath = configuration["Consul:HealthPath"];
        if (!string.IsNullOrEmpty(healthPath))
        {
            this._healthPath = healthPath;
        }
    }

    public async Task Invoke(HttpContext httpContext)
    {
        if (httpContext.Request.Path == this._healthPath)
        {
            httpContext.Response.StatusCode = (int)HttpStatusCode.OK;
            await httpContext.Response.WriteAsync("I'm OK!");
        }
        else
            await this._next(httpContext);
    }
}
```
###### 3.Startup 配置
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
    services.AddSingleton<IConsulClient>(sp =>
    {
        ArgumentCheck.NotNullOrWhiteSpace(this.Configuration["Consul:Address"], "未找到配置中Consul:Address对应的配置");
        return new ConsulClient(c => { c.Address = new Uri(this.Configuration["Consul:Address"]); });
    });
}

// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime lifetime, IConsulClient consulClient, ILogger<Startup> logger)
{
    ...
    app.UseHealth();
    app.UseMvc();
    app.RegisterSpider(lifetime, this.Configuration, consulClient, logger);
}
```